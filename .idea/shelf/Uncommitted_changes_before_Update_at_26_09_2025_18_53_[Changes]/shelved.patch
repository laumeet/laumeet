Index: backend/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from flask import Flask, request, jsonify\r\nfrom flask_sqlalchemy import SQLAlchemy\r\nfrom sqlalchemy import Integer, String, Boolean, DateTime, ForeignKey\r\nfrom sqlalchemy.orm import mapped_column, Mapped, relationship\r\nfrom werkzeug.security import generate_password_hash, check_password_hash\r\nfrom flask_jwt_extended import (\r\n    JWTManager, create_access_token, create_refresh_token,\r\n    jwt_required, get_jwt_identity, get_jwt,\r\n    set_access_cookies, set_refresh_cookies, unset_jwt_cookies\r\n)\r\nfrom datetime import datetime, timedelta, timezone\r\nimport re\r\nimport uuid\r\nimport base64\r\nfrom functools import wraps\r\nfrom flask_cors import CORS\r\nimport time\r\n\r\napp = Flask(__name__)\r\nCORS(app)\r\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///lausers.db'\r\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\r\napp.config['JWT_SECRET_KEY'] = 'your-secret-key-change-this-in-production'  # Change this!\r\napp.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)\r\napp.config['JWT_REFRESH_TOKEN_EXPIRES'] = timedelta(days=14)  # 14-day refresh tokens\r\napp.config['JWT_TOKEN_LOCATION'] = ['cookies', 'headers']\r\napp.config['JWT_COOKIE_SECURE'] = False  # Set to True in production with HTTPS\r\napp.config['JWT_COOKIE_CSRF_PROTECT'] = False\r\n\r\ndb = SQLAlchemy(app)\r\njwt = JWTManager(app)\r\n\r\n# Rate limiting storage\r\nreset_attempts = {}\r\n\r\n\r\ndef rate_limit(max_attempts=5, window_seconds=300):\r\n    def decorator(f):\r\n        @wraps(f)\r\n        def decorated_function(*args, **kwargs):\r\n            ip = request.remote_addr\r\n            username = request.json.get('username') if request.json else None\r\n            key = f\"{ip}:{username}\" if username else ip\r\n            now = time.time()\r\n            reset_attempts[key] = [t for t in reset_attempts.get(key, []) if now - t < window_seconds]\r\n            if len(reset_attempts.get(key, [])) >= max_attempts:\r\n                return jsonify({\r\n                    \"success\": False,\r\n                    \"message\": f\"Too many attempts. Please try again in {window_seconds // 60} minutes.\"\r\n                }), 429\r\n            reset_attempts.setdefault(key, []).append(now)\r\n            return f(*args, **kwargs)\r\n\r\n        return decorated_function\r\n\r\n    return decorator\r\n\r\n\r\n# Picture model\r\nclass Picture(db.Model):\r\n    __tablename__ = \"pictures\"\r\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\r\n    user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)\r\n    image: Mapped[str] = mapped_column(String(500), nullable=False)\r\n    user = relationship(\"User\", back_populates=\"pictures\")\r\n\r\n\r\nclass User(db.Model):\r\n    __tablename__ = \"users\"\r\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\r\n    public_id: Mapped[str] = mapped_column(String(36), unique=True, default=lambda: str(uuid.uuid4()))\r\n    username: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)\r\n    password: Mapped[str] = mapped_column(String(255), nullable=False)\r\n    security_question: Mapped[str] = mapped_column(String(255), nullable=False)\r\n    security_answer: Mapped[str] = mapped_column(String(255), nullable=False)\r\n    name: Mapped[str] = mapped_column(String(100), nullable=True)\r\n    age: Mapped[int] = mapped_column(Integer, nullable=False)\r\n    department: Mapped[str] = mapped_column(String(100), nullable=True)\r\n    gender: Mapped[str] = mapped_column(String(20), nullable=False)\r\n    genotype: Mapped[str] = mapped_column(String(5), nullable=True)\r\n    level: Mapped[str] = mapped_column(String(20), nullable=True)\r\n    interested_in: Mapped[str] = mapped_column(String(50), nullable=True)\r\n    religious: Mapped[str] = mapped_column(String(50), nullable=True)\r\n    is_anonymous: Mapped[bool] = mapped_column(Boolean, default=False)\r\n    category: Mapped[str] = mapped_column(String(50), nullable=False)\r\n    bio: Mapped[str] = mapped_column(String(500), nullable=True)\r\n    timestamp: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)\r\n    last_password_reset: Mapped[datetime] = mapped_column(DateTime, nullable=True)\r\n\r\n    pictures = relationship(\"Picture\", back_populates=\"user\", cascade=\"all, delete-orphan\", passive_deletes=True)\r\n\r\n    def set_password(self, password: str):\r\n        self.password = generate_password_hash(password)\r\n\r\n    def check_password(self, password: str) -> bool:\r\n        return check_password_hash(self.password, password)\r\n\r\n    def set_security_answer(self, answer: str):\r\n        self.security_answer = generate_password_hash(answer.lower().strip())\r\n\r\n    def check_security_answer(self, answer: str) -> bool:\r\n        return check_password_hash(self.security_answer, answer.lower().strip())\r\n\r\n    def to_dict(self, include_security=False):\r\n        data = {\r\n            \"id\": self.public_id,\r\n            \"username\": self.username,\r\n            \"name\": self.name,\r\n            \"age\": str(self.age),\r\n            \"gender\": self.gender,\r\n            \"department\": self.department,\r\n            \"genotype\": self.genotype,\r\n            \"level\": self.level,\r\n            \"interestedIn\": self.interested_in,\r\n            \"religious\": self.religious,\r\n            \"isAnonymous\": self.is_anonymous,\r\n            \"category\": self.category,\r\n            \"bio\": self.bio,\r\n            \"pictures\": [picture.image for picture in self.pictures],\r\n            \"timestamp\": self.timestamp.isoformat() + \"Z\" if self.timestamp else None\r\n        }\r\n        if include_security:\r\n            data[\"security_question\"] = self.security_question\r\n        return data\r\n\r\n    def __repr__(self):\r\n        return f\"<User {self.username}>\"\r\n\r\n\r\nclass TokenBlocklist(db.Model):\r\n    __tablename__ = \"token_blacklist\"\r\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\r\n    jti: Mapped[str] = mapped_column(String(36), nullable=False, index=True)\r\n    token_type: Mapped[str] = mapped_column(String(10), nullable=False)\r\n    user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)\r\n    revoked_at: Mapped[datetime] = mapped_column(DateTime, nullable=False)\r\n    expires: Mapped[datetime] = mapped_column(DateTime, nullable=False)\r\n    user = db.relationship('User', lazy='joined')\r\n\r\n\r\n\r\n\r\ndef is_valid_username(username):\r\n    return bool(username) and 3 <= len(username) <= 50 and re.match(r'^[a-zA-Z0-9_]+$', username)\r\n\r\n\r\ndef is_strong_password(password):\r\n    if not password or len(password) < 8:\r\n        return False\r\n    return any(c.isdigit() for c in password) and any(c.isupper() for c in password)\r\n\r\n\r\ndef validate_gender(gender):\r\n    return bool(gender) and gender.lower() in [\"male\", \"female\", \"other\"]\r\n\r\n\r\ndef is_valid_image_data(image_data, max_size_kb=500):\r\n    if image_data.startswith(('http://', 'https://')):\r\n        return True, \"url\"\r\n    if image_data.startswith('data:image/'):\r\n        try:\r\n            header, data = image_data.split(',', 1)\r\n            base64.b64decode(data)\r\n            size_kb = len(data) * 3 / 4 / 1024\r\n            if size_kb > max_size_kb:\r\n                return False, f\"Image size exceeds {max_size_kb}KB limit\"\r\n            return True, \"base64\"\r\n        except Exception:\r\n            return False, \"Invalid base64 image data\"\r\n    return False, \"Image must be a valid URL or base64 data URI\"\r\n\r\n\r\n@jwt.token_in_blocklist_loader\r\ndef check_if_token_revoked(jwt_header, jwt_payload):\r\n    jti = jwt_payload[\"jti\"]\r\n    return TokenBlocklist.query.filter_by(jti=jti).first() is not None\r\n\r\n\r\n@jwt.user_identity_loader\r\ndef user_identity_lookup(user):\r\n    return user.public_id if isinstance(user, User) else user\r\n\r\n\r\n@jwt.user_lookup_loader\r\ndef user_lookup_callback(_jwt_header, jwt_data):\r\n    return User.query.filter_by(public_id=jwt_data[\"sub\"]).first()\r\n\r\n\r\nwith app.app_context():\r\n    db.create_all()\r\n\r\n\r\n@app.route(\"/\")\r\ndef home():\r\n    return jsonify({\"message\": \"Dating App API\"})\r\n\r\n\r\n\r\n@app.route(\"/signup\", methods=[\"POST\"])\r\ndef signup():\r\n    data = request.json or {}\r\n    username = data.get(\"username\")\r\n    password = data.get(\"password\")\r\n    security_question = data.get(\"security_question\")\r\n    security_answer = data.get(\"security_answer\")\r\n    name = data.get(\"name\")  # <-- added\r\n    age = data.get(\"age\")\r\n    department = data.get(\"department\")\r\n    gender = data.get(\"gender\")\r\n    genotype = data.get(\"genotype\")\r\n    level = data.get(\"level\")\r\n    interested_in = data.get(\"interestedIn\")  # camelCase input â†’ snake_case db\r\n    religious = data.get(\"religious\")\r\n    is_anonymous = data.get(\"isAnonymous\", False)\r\n    category = data.get(\"category\", \"friend\")\r\n    bio = data.get(\"bio\")\r\n    pictures = data.get(\"pictures\", [])\r\n\r\n    # Required fields\r\n    if not username or not password:\r\n        return jsonify({\"success\": False, \"message\": \"Username and password are required\"}), 400\r\n    if not security_question or len(security_question.strip()) < 5:\r\n        return jsonify({\"success\": False, \"message\": \"Security question must be at least 5 characters long\"}), 400\r\n    if not security_answer or len(security_answer.strip()) < 2:\r\n        return jsonify({\"success\": False, \"message\": \"Security answer must be at least 2 characters long\"}), 400\r\n    if not is_valid_username(username):\r\n        return jsonify({\"success\": False, \"message\": \"Invalid username format\"}), 400\r\n    if not is_strong_password(password):\r\n        return jsonify({\"success\": False, \"message\": \"Weak password\"}), 400\r\n\r\n    try:\r\n        age = int(age)\r\n        if age < 18 or age > 100:\r\n            return jsonify({\"success\": False, \"message\": \"Age must be between 18 and 100\"}), 400\r\n    except (ValueError, TypeError):\r\n        return jsonify({\"success\": False, \"message\": \"Age must be a valid number\"}), 400\r\n\r\n    if not validate_gender(gender):\r\n        return jsonify({\"success\": False, \"message\": \"Gender must be male, female, or other\"}), 400\r\n    if not isinstance(is_anonymous, bool):\r\n        return jsonify({\"success\": False, \"message\": \"isAnonymous must be boolean\"}), 400\r\n    if not category:\r\n        return jsonify({\"success\": False, \"message\": \"Category is required\"}), 400\r\n    if len(pictures) > 10:\r\n        return jsonify({\"success\": False, \"message\": \"Max 10 pictures allowed\"}), 400\r\n\r\n    for img in pictures:\r\n        valid, msg = is_valid_image_data(img)\r\n        if not valid:\r\n            return jsonify({\"success\": False, \"message\": f\"Invalid image: {msg}\"}), 400\r\n\r\n    if User.query.filter_by(username=username).first():\r\n        return jsonify({\"success\": False, \"message\": \"Username already taken\"}), 400\r\n\r\n    # Create new user\r\n    new_user = User(\r\n        username=username,\r\n        security_question=security_question.strip(),\r\n        age=age,\r\n        department=department or \"\",   # safe default\r\n        gender=gender.lower(),\r\n        genotype=genotype or \"\",\r\n        level=level or \"\",\r\n        interested_in=interested_in or \"\",\r\n        religious=religious or \"\",\r\n        is_anonymous=is_anonymous,\r\n        category=category,\r\n        bio=bio or \"\",\r\n        name=name or \"\"   # optional but avoids None crash\r\n    )\r\n    new_user.set_password(password)\r\n    new_user.set_security_answer(security_answer)\r\n\r\n    for img in pictures:\r\n        db.session.add(Picture(user=new_user, image=img))\r\n\r\n    db.session.add(new_user)\r\n    db.session.commit()\r\n\r\n    access_token = create_access_token(identity=new_user)\r\n    refresh_token = create_refresh_token(identity=new_user)\r\n\r\n    response = jsonify({\r\n        \"success\": True,\r\n        \"message\": \"User created successfully\",\r\n        \"user\": new_user.to_dict(),\r\n        \"access_token\": access_token,\r\n        \"refresh_token\": refresh_token\r\n    })\r\n    set_access_cookies(response, access_token)\r\n    set_refresh_cookies(response, refresh_token)\r\n    return response, 201\r\n\r\n\r\n@app.route(\"/login\", methods=[\"POST\"])\r\ndef login():\r\n    data = request.json or {}\r\n    username = data.get(\"username\")\r\n    password = data.get(\"password\")\r\n\r\n    if not username or not password:\r\n        return jsonify({\"success\": False, \"message\": \"Username and password required\"}), 400\r\n\r\n    user = User.query.filter_by(username=username).first()\r\n    if not user or not user.check_password(password):\r\n        return jsonify({\"success\": False, \"message\": \"Invalid username or password\"}), 401\r\n\r\n    print(\"\uD83D\uDD0E User fetched from DB:\", user.to_dict())  # Log all info on console\r\n\r\n    access_token = create_access_token(identity=user)\r\n    refresh_token = create_refresh_token(identity=user)\r\n\r\n    response = jsonify({\r\n        \"success\": True,\r\n        \"message\": \"Login successful\",\r\n        \"user\": user.to_dict(),  # This sends all user info to Postman\r\n        \"access_token\": access_token,\r\n        \"refresh_token\": refresh_token\r\n    })\r\n    set_access_cookies(response, access_token)\r\n    set_refresh_cookies(response, refresh_token)\r\n    return response, 200\r\n\r\n\r\n\r\n\r\n@app.route(\"/forgot-password\", methods=[\"POST\"])\r\ndef forgot_password():\r\n    \"\"\"\r\n    Step 1: User submits their username; we return their security question.\r\n    \"\"\"\r\n    data = request.json or {}\r\n    username = data.get(\"username\")\r\n    if not username:\r\n        return jsonify({\"success\": False, \"message\": \"Username required\"}), 400\r\n\r\n    user = User.query.filter_by(username=username).first()\r\n    if not user:\r\n        # Do not reveal that the username doesn't exist (security best practice)\r\n        return jsonify({\"success\": True, \"question\": None}), 200\r\n\r\n    return jsonify({\r\n        \"success\": True,\r\n        \"question\": user.security_question\r\n    }), 200\r\n\r\n\r\n@app.route(\"/reset-password\", methods=[\"POST\"])\r\ndef reset_password():\r\n    \"\"\"\r\n    Step 2: User submits username, security answer, and new password.\r\n    If the answer is correct, we reset their password.\r\n    \"\"\"\r\n    data = request.json or {}\r\n    username = data.get(\"username\")\r\n    answer = data.get(\"security_answer\")\r\n    new_password = data.get(\"new_password\")\r\n\r\n    if not username or not answer or not new_password:\r\n        return jsonify({\"success\": False, \"message\": \"All fields are required\"}), 400\r\n\r\n    user = User.query.filter_by(username=username).first()\r\n    if not user:\r\n        # Do not reveal user existence\r\n        return jsonify({\"success\": False, \"message\": \"Invalid credentials\"}), 400\r\n\r\n    # Check security answer\r\n    if not user.check_security_answer(answer):\r\n        return jsonify({\"success\": False, \"message\": \"Security answer is incorrect\"}), 401\r\n\r\n    # Validate new password strength (optional)\r\n    if not is_strong_password(new_password):\r\n        return jsonify({\"success\": False, \"message\": \"New password is too weak\"}), 400\r\n\r\n    # Reset password\r\n    user.set_password(new_password)\r\n    user.last_password_reset = datetime.utcnow()\r\n    db.session.commit()\r\n\r\n    return jsonify({\"success\": True, \"message\": \"Password reset successfully\"}), 200\r\n\r\n\r\n\r\n@app.route(\"/protected\")\r\n@jwt_required()\r\ndef protected():\r\n    public_id = get_jwt_identity()\r\n    user = User.query.filter_by(public_id=public_id).first()\r\n    if not user:\r\n        return jsonify({\"success\": False, \"message\": \"User not found\"}), 404\r\n    return jsonify({\"success\": True, \"user\": user.to_dict()})\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    with app.app_context():\r\n        db.create_all()\r\n    app.run(debug=True)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/backend/main.py b/backend/main.py
--- a/backend/main.py	(revision bfc5875082a9f2c8458a6f320804dd90e2834b79)
+++ b/backend/main.py	(date 1758857716793)
@@ -1,54 +1,82 @@
-from flask import Flask, request, jsonify
-from flask_sqlalchemy import SQLAlchemy
-from sqlalchemy import Integer, String, Boolean, DateTime, ForeignKey
-from sqlalchemy.orm import mapped_column, Mapped, relationship
-from werkzeug.security import generate_password_hash, check_password_hash
-from flask_jwt_extended import (
+# Import necessary modules and libraries
+from flask import Flask, request, jsonify  # Flask web framework and request/response handling
+from flask_sqlalchemy import SQLAlchemy  # SQLAlchemy for database ORM
+from sqlalchemy import Integer, String, Boolean, DateTime, ForeignKey  # SQLAlchemy column types
+from sqlalchemy.orm import mapped_column, Mapped, relationship  # SQLAlchemy ORM features
+from werkzeug.security import generate_password_hash, check_password_hash  # Password hashing utilities
+from flask_jwt_extended import (  # JWT authentication utilities
     JWTManager, create_access_token, create_refresh_token,
     jwt_required, get_jwt_identity, get_jwt,
     set_access_cookies, set_refresh_cookies, unset_jwt_cookies
 )
-from datetime import datetime, timedelta, timezone
-import re
-import uuid
-import base64
-from functools import wraps
-from flask_cors import CORS
-import time
+from datetime import datetime, timedelta, timezone  # Date and time handling
+import re  # Regular expressions for validation
+import uuid  # UUID generation for unique identifiers
+import base64  # Base64 encoding/decoding for image data
+from functools import wraps  # Decorator utilities
+from flask_cors import CORS  # Cross-Origin Resource Sharing support
+import time  # Time functions for rate limiting
 
+# Initialize Flask application
 app = Flask(__name__)
+# Enable CORS for all routes to allow frontend-backend communication
 CORS(app)
-app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///lausers.db'
-app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
-app.config['JWT_SECRET_KEY'] = 'your-secret-key-change-this-in-production'  # Change this!
-app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)
-app.config['JWT_REFRESH_TOKEN_EXPIRES'] = timedelta(days=14)  # 14-day refresh tokens
-app.config['JWT_TOKEN_LOCATION'] = ['cookies', 'headers']
-app.config['JWT_COOKIE_SECURE'] = False  # Set to True in production with HTTPS
-app.config['JWT_COOKIE_CSRF_PROTECT'] = False
 
-db = SQLAlchemy(app)
-jwt = JWTManager(app)
+# Application configuration settings
+app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///lausers.db'  # Database file path
+app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Disable modification tracking for performance
+app.config[
+    'JWT_SECRET_KEY'] = 'your-secret-key-change-this-in-production'  # Secret key for JWT signing (CHANGE IN PRODUCTION!)
+app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=24)  # Access token expiration time (24 hours)
+app.config['JWT_REFRESH_TOKEN_EXPIRES'] = timedelta(days=14)  # Refresh token expiration time (14 days)
+app.config['JWT_TOKEN_LOCATION'] = ['cookies', 'headers']  # Where to look for JWT tokens
+app.config['JWT_COOKIE_SECURE'] = False  # Only allow HTTPS cookies in production (False for development)
+app.config['JWT_COOKIE_CSRF_PROTECT'] = False  # Disable CSRF protection for simplicity
 
-# Rate limiting storage
+# Initialize database and JWT manager
+db = SQLAlchemy(app)  # Database instance
+jwt = JWTManager(app)  # JWT manager instance
+
+# Rate limiting storage - stores attempt timestamps for each IP/username combination
+# In production, consider using Redis instead of in-memory dictionary
 reset_attempts = {}
 
 
 def rate_limit(max_attempts=5, window_seconds=300):
+    """
+    Decorator function to implement rate limiting on routes
+    Args:
+        max_attempts: Maximum number of allowed attempts
+        window_seconds: Time window in seconds for counting attempts
+    Returns:
+        Decorator function that applies rate limiting
+    """
+
     def decorator(f):
         @wraps(f)
         def decorated_function(*args, **kwargs):
+            # Get client IP address and username from request
             ip = request.remote_addr
             username = request.json.get('username') if request.json else None
+            # Create unique key for rate limiting (IP + username if available)
             key = f"{ip}:{username}" if username else ip
-            now = time.time()
+
+            now = time.time()  # Current timestamp
+
+            # Clean old attempts: remove attempts older than the time window
             reset_attempts[key] = [t for t in reset_attempts.get(key, []) if now - t < window_seconds]
+
+            # Check if user has exceeded the maximum allowed attempts
             if len(reset_attempts.get(key, [])) >= max_attempts:
                 return jsonify({
                     "success": False,
                     "message": f"Too many attempts. Please try again in {window_seconds // 60} minutes."
-                }), 429
+                }), 429  # HTTP 429 Too Many Requests
+
+            # Add current attempt timestamp to the list
             reset_attempts.setdefault(key, []).append(now)
+
+            # Proceed with the original function if rate limit not exceeded
             return f(*args, **kwargs)
 
         return decorated_function
@@ -56,289 +84,450 @@
     return decorator
 
 
-# Picture model
+# Database Models
+
+# Picture model for storing user profile images
 class Picture(db.Model):
-    __tablename__ = "pictures"
+    __tablename__ = "pictures"  # Database table name
+
+    # Primary key
     id: Mapped[int] = mapped_column(Integer, primary_key=True)
+    # Foreign key to users table with cascade delete (pictures deleted when user is deleted)
     user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
+    # Image data (URL or base64 encoded string)
     image: Mapped[str] = mapped_column(String(500), nullable=False)
+    # Relationship to User model (back reference)
     user = relationship("User", back_populates="pictures")
 
 
+# Main User model for storing user information
 class User(db.Model):
-    __tablename__ = "users"
+    __tablename__ = "users"  # Database table name
+
+    # Primary key (auto-incrementing integer)
     id: Mapped[int] = mapped_column(Integer, primary_key=True)
+    # Public unique identifier (UUID) for external use (more secure than exposing database ID)
     public_id: Mapped[str] = mapped_column(String(36), unique=True, default=lambda: str(uuid.uuid4()))
+    # Username (must be unique and not null)
     username: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)
+    # Hashed password (never store plain text passwords!)
     password: Mapped[str] = mapped_column(String(255), nullable=False)
+    # Security question for password recovery
     security_question: Mapped[str] = mapped_column(String(255), nullable=False)
+    # Hashed security answer (never store plain text!)
     security_answer: Mapped[str] = mapped_column(String(255), nullable=False)
+    # User's full name (optional)
     name: Mapped[str] = mapped_column(String(100), nullable=True)
+    # User's age (must be provided)
     age: Mapped[int] = mapped_column(Integer, nullable=False)
+    # Department/field of study (optional)
     department: Mapped[str] = mapped_column(String(100), nullable=True)
+    # Gender (must be provided)
     gender: Mapped[str] = mapped_column(String(20), nullable=False)
+    # Blood genotype (optional)
     genotype: Mapped[str] = mapped_column(String(5), nullable=True)
+    # Academic level (optional)
     level: Mapped[str] = mapped_column(String(20), nullable=True)
+    # What the user is interested in (dating, friends, etc.)
     interested_in: Mapped[str] = mapped_column(String(50), nullable=True)
+    # Religious affiliation (optional)
     religious: Mapped[str] = mapped_column(String(50), nullable=True)
+    # Whether user wants to remain anonymous
     is_anonymous: Mapped[bool] = mapped_column(Boolean, default=False)
+    # User category (hookup, friend, dating, etc.)
     category: Mapped[str] = mapped_column(String(50), nullable=False)
+    # User biography/description
     bio: Mapped[str] = mapped_column(String(500), nullable=True)
+    # Account creation timestamp (automatically set to current UTC time)
     timestamp: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
+    # Last password reset timestamp (for security cooldown)
     last_password_reset: Mapped[datetime] = mapped_column(DateTime, nullable=True)
 
+    # Relationship to Picture model - one user can have many pictures
+    # cascade="all, delete-orphan" ensures pictures are deleted when user is deleted
+    # passive_deletes=True improves performance for cascade operations
     pictures = relationship("Picture", back_populates="user", cascade="all, delete-orphan", passive_deletes=True)
 
     def set_password(self, password: str):
+        """Hash and set the user's password"""
         self.password = generate_password_hash(password)
 
     def check_password(self, password: str) -> bool:
+        """Verify if the provided password matches the stored hash"""
         return check_password_hash(self.password, password)
 
     def set_security_answer(self, answer: str):
+        """Hash and set the security answer (normalize to lowercase and strip whitespace)"""
         self.security_answer = generate_password_hash(answer.lower().strip())
 
     def check_security_answer(self, answer: str) -> bool:
+        """Verify if the provided security answer matches the stored hash"""
         return check_password_hash(self.security_answer, answer.lower().strip())
 
     def to_dict(self, include_security=False):
+        """
+        Convert User object to dictionary for JSON response
+        Args:
+            include_security: Whether to include security-related fields (should be False for most responses)
+        Returns:
+            Dictionary representation of the user
+        """
         data = {
-            "id": self.public_id,
+            "id": self.public_id,  # Use public_id instead of database ID for security
             "username": self.username,
             "name": self.name,
-            "age": str(self.age),
+            "age": str(self.age),  # Convert to string for consistency with frontend
             "gender": self.gender,
             "department": self.department,
             "genotype": self.genotype,
             "level": self.level,
-            "interestedIn": self.interested_in,
+            "interestedIn": self.interested_in,  # CamelCase for frontend compatibility
             "religious": self.religious,
-            "isAnonymous": self.is_anonymous,
+            "isAnonymous": self.is_anonymous,  # CamelCase for frontend compatibility
             "category": self.category,
             "bio": self.bio,
-            "pictures": [picture.image for picture in self.pictures],
-            "timestamp": self.timestamp.isoformat() + "Z" if self.timestamp else None
+            "pictures": [picture.image for picture in self.pictures],  # List of image URLs/data
+            "timestamp": self.timestamp.isoformat() + "Z" if self.timestamp else None  # ISO format with Zulu time
         }
+        # Only include security question if explicitly requested (rarely needed)
         if include_security:
             data["security_question"] = self.security_question
+            # Never include security_answer in responses!
         return data
 
     def __repr__(self):
+        """String representation of User object for debugging"""
         return f"<User {self.username}>"
 
 
+# Token blacklist model for storing revoked JWT tokens
 class TokenBlocklist(db.Model):
-    __tablename__ = "token_blacklist"
+    __tablename__ = "token_blacklist"  # Database table name
+
+    # Primary key
     id: Mapped[int] = mapped_column(Integer, primary_key=True)
+    # JWT ID (unique identifier for each token)
     jti: Mapped[str] = mapped_column(String(36), nullable=False, index=True)
+    # Type of token (access or refresh)
     token_type: Mapped[str] = mapped_column(String(10), nullable=False)
+    # Foreign key to users table
     user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
+    # When the token was revoked
     revoked_at: Mapped[datetime] = mapped_column(DateTime, nullable=False)
+    # When the token expires (for automatic cleanup)
     expires: Mapped[datetime] = mapped_column(DateTime, nullable=False)
+    # Relationship to User model
     user = db.relationship('User', lazy='joined')
 
 
-
+# Validation Functions
 
 def is_valid_username(username):
+    """
+    Validate username format
+    Rules:
+    - Must not be empty
+    - Must be between 3 and 50 characters
+    - Can only contain letters, numbers, and underscores
+    """
     return bool(username) and 3 <= len(username) <= 50 and re.match(r'^[a-zA-Z0-9_]+$', username)
 
 
 def is_strong_password(password):
+    """
+    Validate password strength
+    Rules:
+    - Must not be empty
+    - Must be at least 8 characters long
+    - Must contain at least one digit
+    - Must contain at least one uppercase letter
+    """
     if not password or len(password) < 8:
         return False
     return any(c.isdigit() for c in password) and any(c.isupper() for c in password)
 
 
 def validate_gender(gender):
+    """
+    Validate gender value
+    Allowed values: "male", "female", "other" (case-insensitive)
+    """
     return bool(gender) and gender.lower() in ["male", "female", "other"]
 
 
 def is_valid_image_data(image_data, max_size_kb=500):
+    """
+    Validate image data (either URL or base64 encoded)
+    Args:
+        image_data: The image data to validate
+        max_size_kb: Maximum allowed size in kilobytes (for base64 images)
+    Returns:
+        Tuple of (is_valid, message)
+    """
+    # Check if it's a URL (http:// or https://)
     if image_data.startswith(('http://', 'https://')):
         return True, "url"
+
+    # Check if it's base64 encoded image data
     if image_data.startswith('data:image/'):
         try:
+            # Split data URI header from base64 data
             header, data = image_data.split(',', 1)
+            # Verify it's valid base64
             base64.b64decode(data)
+
+            # Calculate approximate size (base64 is about 33% larger than binary)
             size_kb = len(data) * 3 / 4 / 1024
             if size_kb > max_size_kb:
                 return False, f"Image size exceeds {max_size_kb}KB limit"
+
             return True, "base64"
         except Exception:
+            # Catch any errors in base64 decoding
             return False, "Invalid base64 image data"
+
+    # Not a URL or valid base64
     return False, "Image must be a valid URL or base64 data URI"
 
 
+# JWT Configuration Callbacks
+
 @jwt.token_in_blocklist_loader
 def check_if_token_revoked(jwt_header, jwt_payload):
-    jti = jwt_payload["jti"]
+    """
+    Check if a JWT token has been revoked (added to blacklist)
+    This is called automatically by flask_jwt_extended
+    """
+    jti = jwt_payload["jti"]  # Get JWT ID from payload
     return TokenBlocklist.query.filter_by(jti=jti).first() is not None
 
 
 @jwt.user_identity_loader
 def user_identity_lookup(user):
+    """
+    Specify what data to use as identity in JWT tokens
+    We use public_id instead of database ID for security
+    """
     return user.public_id if isinstance(user, User) else user
 
 
 @jwt.user_lookup_loader
 def user_lookup_callback(_jwt_header, jwt_data):
+    """
+    Load user from database based on JWT identity
+    This is called when we use @jwt_required()
+    """
     return User.query.filter_by(public_id=jwt_data["sub"]).first()
 
 
+# Initialize database tables
 with app.app_context():
-    db.create_all()
+    db.create_all()  # Create all tables if they don't exist
 
+
+# Route Handlers
 
 @app.route("/")
 def home():
+    """Root endpoint - simple API greeting"""
     return jsonify({"message": "Dating App API"})
 
 
-
 @app.route("/signup", methods=["POST"])
 def signup():
+    """
+    User registration endpoint
+    Creates a new user account with provided information
+    """
+    # Get JSON data from request body, default to empty dict if None
     data = request.json or {}
+
+    # Extract all fields from request data
     username = data.get("username")
     password = data.get("password")
     security_question = data.get("security_question")
     security_answer = data.get("security_answer")
-    name = data.get("name")  # <-- added
+    name = data.get("name")  # Optional field
     age = data.get("age")
-    department = data.get("department")
+    department = data.get("department")  # Optional field
     gender = data.get("gender")
-    genotype = data.get("genotype")
-    level = data.get("level")
-    interested_in = data.get("interestedIn")  # camelCase input â†’ snake_case db
-    religious = data.get("religious")
-    is_anonymous = data.get("isAnonymous", False)
-    category = data.get("category", "friend")
-    bio = data.get("bio")
-    pictures = data.get("pictures", [])
+    genotype = data.get("genotype")  # Optional field
+    level = data.get("level")  # Optional field
+    interested_in = data.get("interestedIn")  # camelCase input â†’ snake_case db field
+    religious = data.get("religious")  # Optional field
+    is_anonymous = data.get("isAnonymous", False)  # Default to False
+    category = data.get("category", "friend")  # Default to "friend"
+    bio = data.get("bio")  # Optional field
+    pictures = data.get("pictures", [])  # List of images, default to empty list
 
-    # Required fields
+    # Required fields validation
     if not username or not password:
         return jsonify({"success": False, "message": "Username and password are required"}), 400
+
+    # Security question validation
     if not security_question or len(security_question.strip()) < 5:
         return jsonify({"success": False, "message": "Security question must be at least 5 characters long"}), 400
+
+    # Security answer validation
     if not security_answer or len(security_answer.strip()) < 2:
         return jsonify({"success": False, "message": "Security answer must be at least 2 characters long"}), 400
+
+    # Username format validation
     if not is_valid_username(username):
         return jsonify({"success": False, "message": "Invalid username format"}), 400
+
+    # Password strength validation
     if not is_strong_password(password):
         return jsonify({"success": False, "message": "Weak password"}), 400
 
+    # Age validation
     try:
-        age = int(age)
-        if age < 18 or age > 100:
+        age = int(age)  # Convert to integer
+        if age < 18 or age > 100:  # Reasonable age range for dating app
             return jsonify({"success": False, "message": "Age must be between 18 and 100"}), 400
     except (ValueError, TypeError):
         return jsonify({"success": False, "message": "Age must be a valid number"}), 400
 
+    # Gender validation
     if not validate_gender(gender):
         return jsonify({"success": False, "message": "Gender must be male, female, or other"}), 400
+
+    # isAnonymous must be boolean
     if not isinstance(is_anonymous, bool):
         return jsonify({"success": False, "message": "isAnonymous must be boolean"}), 400
+
+    # Category is required
     if not category:
         return jsonify({"success": False, "message": "Category is required"}), 400
+
+    # Limit number of pictures to prevent abuse
     if len(pictures) > 10:
         return jsonify({"success": False, "message": "Max 10 pictures allowed"}), 400
 
+    # Validate each picture
     for img in pictures:
         valid, msg = is_valid_image_data(img)
         if not valid:
             return jsonify({"success": False, "message": f"Invalid image: {msg}"}), 400
 
+    # Check if username already exists in database
     if User.query.filter_by(username=username).first():
         return jsonify({"success": False, "message": "Username already taken"}), 400
 
-    # Create new user
+    # Create new user object with all provided data
     new_user = User(
         username=username,
-        security_question=security_question.strip(),
+        security_question=security_question.strip(),  # Remove extra whitespace
         age=age,
-        department=department or "",   # safe default
-        gender=gender.lower(),
-        genotype=genotype or "",
-        level=level or "",
-        interested_in=interested_in or "",
-        religious=religious or "",
+        department=department or "",  # Provide empty string if None
+        gender=gender.lower(),  # Store in lowercase for consistency
+        genotype=genotype or "",  # Provide empty string if None
+        level=level or "",  # Provide empty string if None
+        interested_in=interested_in or "",  # Provide empty string if None
+        religious=religious or "",  # Provide empty string if None
         is_anonymous=is_anonymous,
         category=category,
-        bio=bio or "",
-        name=name or ""   # optional but avoids None crash
+        bio=bio or "",  # Provide empty string if None
+        name=name or ""  # Provide empty string if None
     )
+
+    # Set hashed password and security answer
     new_user.set_password(password)
     new_user.set_security_answer(security_answer)
 
+    # Add pictures to database
     for img in pictures:
         db.session.add(Picture(user=new_user, image=img))
 
+    # Add user to database session and commit
     db.session.add(new_user)
     db.session.commit()
 
+    # Create JWT tokens for immediate login after signup
     access_token = create_access_token(identity=new_user)
     refresh_token = create_refresh_token(identity=new_user)
 
+    # Prepare success response
     response = jsonify({
         "success": True,
         "message": "User created successfully",
-        "user": new_user.to_dict(),
+        "user": new_user.to_dict(),  # Return user data without sensitive fields
         "access_token": access_token,
         "refresh_token": refresh_token
     })
+
+    # Set JWT tokens as HTTP cookies (optional, for browser-based clients)
     set_access_cookies(response, access_token)
     set_refresh_cookies(response, refresh_token)
-    return response, 201
+
+    return response, 201  # HTTP 201 Created
 
 
 @app.route("/login", methods=["POST"])
 def login():
-    data = request.json or {}
+    """
+    User authentication endpoint
+    Verifies credentials and returns JWT tokens if valid
+    """
+    data = request.json or {}  # Get request data
     username = data.get("username")
     password = data.get("password")
 
+    # Basic validation
     if not username or not password:
         return jsonify({"success": False, "message": "Username and password required"}), 400
 
+    # Find user by username
     user = User.query.filter_by(username=username).first()
+
+    # Check if user exists and password is correct
     if not user or not user.check_password(password):
         return jsonify({"success": False, "message": "Invalid username or password"}), 401
 
-    print("ðŸ”Ž User fetched from DB:", user.to_dict())  # Log all info on console
+    # Debug logging (remove in production)
+    print("ðŸ”Ž User fetched from DB:", user.to_dict())
 
+    # Create JWT tokens
     access_token = create_access_token(identity=user)
     refresh_token = create_refresh_token(identity=user)
 
+    # Prepare success response
     response = jsonify({
         "success": True,
         "message": "Login successful",
-        "user": user.to_dict(),  # This sends all user info to Postman
+        "user": user.to_dict(),  # Return user profile data
         "access_token": access_token,
         "refresh_token": refresh_token
     })
+
+    # Set tokens as cookies
     set_access_cookies(response, access_token)
     set_refresh_cookies(response, refresh_token)
-    return response, 200
 
-
+    return response, 200  # HTTP 200 OK
 
 
 @app.route("/forgot-password", methods=["POST"])
 def forgot_password():
     """
-    Step 1: User submits their username; we return their security question.
+    Step 1 of password reset process
+    User submits username, system returns their security question
     """
     data = request.json or {}
     username = data.get("username")
+
     if not username:
         return jsonify({"success": False, "message": "Username required"}), 400
 
+    # Find user by username
     user = User.query.filter_by(username=username).first()
+
     if not user:
-        # Do not reveal that the username doesn't exist (security best practice)
+        # Security best practice: don't reveal if username exists
+        # Return success but with null question to avoid user enumeration
         return jsonify({"success": True, "question": None}), 200
 
+    # Return the user's security question
     return jsonify({
         "success": True,
         "question": user.security_question
@@ -348,31 +537,35 @@
 @app.route("/reset-password", methods=["POST"])
 def reset_password():
     """
-    Step 2: User submits username, security answer, and new password.
-    If the answer is correct, we reset their password.
+    Step 2 of password reset process
+    User submits username, security answer, and new password
+    If answer is correct, password is reset
     """
     data = request.json or {}
     username = data.get("username")
     answer = data.get("security_answer")
     new_password = data.get("new_password")
 
+    # Validate all required fields are present
     if not username or not answer or not new_password:
         return jsonify({"success": False, "message": "All fields are required"}), 400
 
+    # Find user by username
     user = User.query.filter_by(username=username).first()
+
     if not user:
-        # Do not reveal user existence
+        # Security best practice: don't reveal if username exists
         return jsonify({"success": False, "message": "Invalid credentials"}), 400
 
-    # Check security answer
+    # Verify security answer
     if not user.check_security_answer(answer):
         return jsonify({"success": False, "message": "Security answer is incorrect"}), 401
 
-    # Validate new password strength (optional)
+    # Validate new password strength
     if not is_strong_password(new_password):
         return jsonify({"success": False, "message": "New password is too weak"}), 400
 
-    # Reset password
+    # Reset password and update timestamp
     user.set_password(new_password)
     user.last_password_reset = datetime.utcnow()
     db.session.commit()
@@ -380,18 +573,96 @@
     return jsonify({"success": True, "message": "Password reset successfully"}), 200
 
 
+@app.route("/profile", methods=["GET"])
+@jwt_required()  # Require valid JWT token to access this endpoint
+def get_my_profile():
+    """
+    Get current user's profile information
+    Requires authentication via JWT
+    """
+    # Get user identity from JWT token
+    public_id = get_jwt_identity()
+
+    # Find user by public_id
+    user = User.query.filter_by(public_id=public_id).first()
+
+    if not user:
+        return jsonify({"success": False, "message": "User not found"}), 404
+
+    # Return user profile data
+    return jsonify({
+        "success": True,
+        "user": user.to_dict()
+    }), 200
+
+
+@app.route("/profile", methods=["PUT"])
+@jwt_required()  # Require valid JWT token to access this endpoint
+def update_my_profile():
+    """
+    Update current user's profile information
+    Requires authentication via JWT
+    """
+    # Get user identity from JWT token
+    public_id = get_jwt_identity()
+
+    # Find user by public_id
+    user = User.query.filter_by(public_id=public_id).first()
+
+    if not user:
+        return jsonify({"success": False, "message": "User not found"}), 404
+
+    data = request.json or {}  # Get update data from request
+
+    # Update allowed fields with new values or keep existing ones
+    user.name = data.get("name", user.name)
+    user.bio = data.get("bio", user.bio)
+    user.department = data.get("department", user.department)
+    user.category = data.get("category", user.category)
+    user.gender = data.get("gender", user.gender)
+    user.interested_in = data.get("interestedIn", user.interested_in)
+
+    # Validate bio length (prevent excessively long bios)
+    if user.bio and len(user.bio) > 500:
+        return jsonify({"success": False, "message": "Bio too long (max 500 chars)"}), 400
+
+    # Validate gender value
+    if user.gender and not validate_gender(user.gender):
+        return jsonify({"success": False, "message": "Invalid gender"}), 400
+
+    # Save changes to database
+    db.session.commit()
+
+    # Return updated user data
+    return jsonify({
+        "success": True,
+        "message": "Profile updated successfully",
+        "user": user.to_dict()
+    }), 200
+
 
 @app.route("/protected")
-@jwt_required()
+@jwt_required()  # Require valid JWT token to access this endpoint
 def protected():
+    """
+    Protected endpoint example - requires authentication
+    Useful for testing if JWT authentication is working
+    """
     public_id = get_jwt_identity()
     user = User.query.filter_by(public_id=public_id).first()
+
     if not user:
         return jsonify({"success": False, "message": "User not found"}), 404
+
     return jsonify({"success": True, "user": user.to_dict()})
 
 
+# Application entry point
 if __name__ == "__main__":
+    # Ensure database tables are created before running the app
     with app.app_context():
         db.create_all()
-    app.run(debug=True)
+
+    # Start the Flask development server
+    # debug=True enables auto-reload and detailed error pages (disable in production!)
+    app.run(debug=True)
\ No newline at end of file
